<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="IOS开发，喜欢刨根问底，热爱技术，热爱Swift、React-Native、JS，混合开发。"><title>iOS中的Category详解 | 崔浩楠 Blog</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/6.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.2/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.2/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">iOS中的Category详解</h1><a id="logo" href="/.">崔浩楠 Blog</a><p class="description">倘能生存，我当然仍要学习。</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">iOS中的Category详解</h1><div class="post-meta">Aug 25, 2017<script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> 阅读</span></span></div><a href="/2017/08/25/iOS中的Category详解/#comments" class="ds-thread-count cloud-tie-join-count"><span style="font-size: 15px; color: #6E7173;" class="join-count">0</span><span> 条参与</span></a><div class="clear"><div id="toc" class="toc-article"><div class="toc-title">文章目录</div><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#简介"><span class="toc-number">1.</span> <span class="toc-text">简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#category简介"><span class="toc-number">2.</span> <span class="toc-text">category简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#category与extension的区别"><span class="toc-number">3.</span> <span class="toc-text">category与extension的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#category如何加载并且添加到类"><span class="toc-number">4.</span> <span class="toc-text">category如何加载并且添加到类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#获取主类方法"><span class="toc-number">5.</span> <span class="toc-text">获取主类方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#category对象关联"><span class="toc-number">6.</span> <span class="toc-text">category对象关联</span></a></li></ol></div></div><div class="post-content"><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>当我们功能越来越多时，单一文件的体积就会变大，甚至臃肿。而多人配合开发一个文件时，还会出现不少冲突，这时就要用相应的解决方法，就是category。<br>这篇文章将会从几个方向出发，详细的了解category的实现机制。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">1. category简介。</div><div class="line">2. category与extension的区别</div><div class="line">3. category如何加载并且添加到类</div><div class="line">4. category对象关联</div></pre></td></tr></table></figure></p>
<h3 id="category简介"><a href="#category简介" class="headerlink" title="category简介"></a>category简介</h3><p>category是在2.0之后添加的特性，作用是可以为存在的文件添加方法，我们列举几个常用的场景：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">1. 模拟多继承</div><div class="line">2. 将私有API公开</div><div class="line">3. 将一个类中的代码分散出来管理</div><div class="line">4. 私有方法</div><div class="line">5. ......</div></pre></td></tr></table></figure></p>
<p>category有很多可以挖掘的地方，下面我们就来一步一步揭开它的面纱</p>
<h3 id="category与extension的区别"><a href="#category与extension的区别" class="headerlink" title="category与extension的区别"></a>category与extension的区别</h3><p>extension是在编译期决定，category由运行期决定，这就是他们不同的根本之处。它决定了他们之间的分工与区别。</p>
<p>extension的生命周期跟随主类，用于隐藏私有信息，你必须拥有这个类的实现/源码，你才可以为它添加extension。见<a href="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/ProgrammingWithObjectiveC/CustomizingExistingClasses/CustomizingExistingClasses.html" target="_blank" rel="external">extension</a></p>
<p>category无法添加实例变量，在运行期间，<strong>对象内存布局已经确认</strong>，这时你无法破坏已经存在的内存空间，所以无法进行实例变量的添加。</p>
<h3 id="category如何加载并且添加到类"><a href="#category如何加载并且添加到类" class="headerlink" title="category如何加载并且添加到类"></a>category如何加载并且添加到类</h3><p>在OC的runtime层中，都是用struct来表示，category由结构体<strong>category_t</strong>表示，(objc-runtime-new.h中可以找到)，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">typedef struct category_t &#123;</div><div class="line">    const char *name;  //类名</div><div class="line">    classref_t cls;  //类</div><div class="line">    struct method_list_t *instanceMethods;  //添加的实例方法列表</div><div class="line">    struct method_list_t *classMethods;  //添加的类方法列表</div><div class="line">    struct protocol_list_t *protocols;  //添加的协议列表</div><div class="line">    struct property_list_t *instanceProperties;  //添加的所有属性</div><div class="line">&#125; category_t;</div></pre></td></tr></table></figure>
<p>那么category如何加载？<br>在OC运行时中，入口方法如下(在objc-os.mm)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">void _objc_init(void)</div><div class="line">&#123;</div><div class="line">    static bool initialized = false;</div><div class="line">    if (initialized) return;</div><div class="line">    initialized = true;</div><div class="line"></div><div class="line">    // fixme defer initialization until an objc-using image is found?</div><div class="line">    environ_init();</div><div class="line">    tls_init();</div><div class="line">    lock_init();</div><div class="line">    exception_init();</div><div class="line"></div><div class="line">    // Register for unmap first, in case some +load unmaps something</div><div class="line">    _dyld_register_func_for_remove_image(&amp;unmap_image);</div><div class="line">    dyld_register_image_state_change_handler(dyld_image_state_bound,</div><div class="line">                                             1/*batch*/, &amp;map_images);</div><div class="line">    dyld_register_image_state_change_handler(dyld_image_state_dependents_initialized, 0/*not batch*/, &amp;load_images);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p> category被附加到类上面是在map_images时发送，在new-ABI的标准下，map_images最终会调用objc-runtime-new.mm文件中_read_images方法，我们来看一下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div></pre></td><td class="code"><pre><div class="line">void _read_images(header_info **hList, uint32_t hCount)</div><div class="line">&#123;</div><div class="line">    ...</div><div class="line">        _free_internal(resolvedFutureClasses);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // Discover categories. </div><div class="line">    for (EACH_HEADER) &#123;</div><div class="line">        category_t **catlist =</div><div class="line">            _getObjc2CategoryList(hi, &amp;count);</div><div class="line">        for (i = 0; i &lt; count; i++) &#123;</div><div class="line">            category_t *cat = catlist[i];</div><div class="line">            Class cls = remapClass(cat-&gt;cls);</div><div class="line"></div><div class="line">            if (!cls) &#123;</div><div class="line">                // Category&apos;s target class is missing (probably weak-linked).</div><div class="line">                // Disavow any knowledge of this category.</div><div class="line">                catlist[i] = nil;</div><div class="line">                if (PrintConnecting) &#123;</div><div class="line">                    _objc_inform(&quot;CLASS: IGNORING category \?\?\?(%s) %p with &quot;</div><div class="line">                                 &quot;missing weak-linked target class&quot;,</div><div class="line">                                 cat-&gt;name, cat);</div><div class="line">                &#125;</div><div class="line">                continue;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            // Process this category. </div><div class="line">            // First, register the category with its target class. </div><div class="line">            // Then, rebuild the class&apos;s method lists (etc) if </div><div class="line">            // the class is realized. </div><div class="line">            BOOL classExists = NO;</div><div class="line">            if (cat-&gt;instanceMethods ||  cat-&gt;protocols</div><div class="line">                ||  cat-&gt;instanceProperties)</div><div class="line">            &#123;</div><div class="line">                addUnattachedCategoryForClass(cat, cls, hi);</div><div class="line">                if (cls-&gt;isRealized()) &#123;</div><div class="line">                    remethodizeClass(cls);</div><div class="line">                    classExists = YES;</div><div class="line">                &#125;</div><div class="line">                if (PrintConnecting) &#123;</div><div class="line">                    _objc_inform(&quot;CLASS: found category -%s(%s) %s&quot;,</div><div class="line">                                 cls-&gt;nameForLogging(), cat-&gt;name,</div><div class="line">                                 classExists ? &quot;on existing class&quot; : &quot;&quot;);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            if (cat-&gt;classMethods  ||  cat-&gt;protocols</div><div class="line">                /* ||  cat-&gt;classProperties */)</div><div class="line">            &#123;</div><div class="line">                addUnattachedCategoryForClass(cat, cls-&gt;ISA(), hi);</div><div class="line">                if (cls-&gt;ISA()-&gt;isRealized()) &#123;</div><div class="line">                    remethodizeClass(cls-&gt;ISA());</div><div class="line">                &#125;</div><div class="line">                if (PrintConnecting) &#123;</div><div class="line">                    _objc_inform(&quot;CLASS: found category +%s(%s)&quot;,</div><div class="line">                                 cls-&gt;nameForLogging(), cat-&gt;name);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // Category discovery MUST BE LAST to avoid potential races </div><div class="line">    // when other threads call the new category code before </div><div class="line">    // this thread finishes its fixups.</div><div class="line"></div><div class="line">    // +load handled by prepare_load_methods()</div><div class="line"></div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里我们可以看出</p>
<ol>
<li>将category的实例方法、属性添加到主类中</li>
<li>将category的类方法添加到元类(metaclass)中</li>
</ol>
<p>无论哪种情况，最后都是通过调用<strong>static void remethodizeClass(Class cls)</strong>函数来重新整理类数据。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line">static void remethodizeClass(class_t *cls)</div><div class="line">&#123;</div><div class="line">    category_list *cats;</div><div class="line">    BOOL isMeta;</div><div class="line"></div><div class="line">    rwlock_assert_writing(&amp;runtimeLock);</div><div class="line"></div><div class="line">    isMeta = isMetaClass(cls);</div><div class="line"></div><div class="line">    // Re-methodizing: check for more categories</div><div class="line">    if ((cats = unattachedCategoriesForClass(cls))) &#123;</div><div class="line">        chained_property_list *newproperties;</div><div class="line">        const protocol_list_t **newprotos;</div><div class="line"></div><div class="line">        if (PrintConnecting) &#123;</div><div class="line">            _objc_inform(&quot;CLASS: attaching categories to class &apos;%s&apos; %s&quot;,</div><div class="line">                         getName(cls), isMeta ? &quot;(meta)&quot; : &quot;&quot;);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        // Update methods, properties, protocols</div><div class="line"></div><div class="line">        BOOL vtableAffected = NO;</div><div class="line">        attachCategoryMethods(cls, cats, &amp;vtableAffected);</div><div class="line"></div><div class="line">        newproperties = buildPropertyList(NULL, cats, isMeta);</div><div class="line">        if (newproperties) &#123;</div><div class="line">            newproperties-&gt;next = cls-&gt;data()-&gt;properties;</div><div class="line">            cls-&gt;data()-&gt;properties = newproperties;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        newprotos = buildProtocolList(cats, NULL, cls-&gt;data()-&gt;protocols);</div><div class="line">        if (cls-&gt;data()-&gt;protocols  &amp;&amp;  cls-&gt;data()-&gt;protocols != newprotos) &#123;</div><div class="line">            _free_internal(cls-&gt;data()-&gt;protocols);</div><div class="line">        &#125;</div><div class="line">        cls-&gt;data()-&gt;protocols = newprotos;</div><div class="line"></div><div class="line">        _free_internal(cats);</div><div class="line"></div><div class="line">        // Update method caches and vtables</div><div class="line">        flushCaches(cls);</div><div class="line">        if (vtableAffected) flushVtables(cls);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>此函数的作用是将category中的方法、属性、协议整合到主类/元类中，更新数据字段 data()中的 <em>*method_lists、properties、protocols， 对于添加实例方法，则会调用</em> attachCategoryMethods*，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">static void </div><div class="line">attachCategoryMethods(class_t *cls, category_list *cats,</div><div class="line">                      BOOL *inoutVtablesAffected)</div><div class="line">&#123;</div><div class="line">    if (!cats) return;</div><div class="line">    if (PrintReplacedMethods) printReplacements(cls, cats);</div><div class="line"></div><div class="line">    BOOL isMeta = isMetaClass(cls);</div><div class="line">    method_list_t **mlists = (method_list_t **)</div><div class="line">        _malloc_internal(cats-&gt;count * sizeof(*mlists));</div><div class="line"></div><div class="line">    // Count backwards through cats to get newest categories first</div><div class="line">    int mcount = 0;</div><div class="line">    int i = cats-&gt;count;</div><div class="line">    BOOL fromBundle = NO;</div><div class="line">    while (i--) &#123;</div><div class="line">        method_list_t *mlist = cat_method_list(cats-&gt;list[i].cat, isMeta);</div><div class="line">        if (mlist) &#123;</div><div class="line">            mlists[mcount++] = mlist;</div><div class="line">            fromBundle |= cats-&gt;list[i].fromBundle;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    attachMethodLists(cls, mlists, mcount, NO, fromBundle, inoutVtablesAffected);</div><div class="line"></div><div class="line">    _free_internal(mlists);</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>它的工作可以看成将category的实例方法列表拼成一个实例方法列表，然后调用<strong>attachMethodLists</strong>进行处理。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">for (uint32_t m = 0;</div><div class="line">             (scanForCustomRR || scanForCustomAWZ)  &amp;&amp;  m &lt; mlist-&gt;count;</div><div class="line">             m++)</div><div class="line">        &#123;</div><div class="line">            SEL sel = method_list_nth(mlist, m)-&gt;name;</div><div class="line">            if (scanForCustomRR  &amp;&amp;  isRRSelector(sel)) &#123;</div><div class="line">                cls-&gt;setHasCustomRR();</div><div class="line">                scanForCustomRR = false;</div><div class="line">            &#125; else if (scanForCustomAWZ  &amp;&amp;  isAWZSelector(sel)) &#123;</div><div class="line">                cls-&gt;setHasCustomAWZ();</div><div class="line">                scanForCustomAWZ = false;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        // Fill method list array</div><div class="line">        newLists[newCount++] = mlist;</div><div class="line">    .</div><div class="line">    .</div><div class="line">    .</div><div class="line"></div><div class="line">    // Copy old methods to the method list array</div><div class="line">    for (i = 0; i &lt; oldCount; i++) &#123;</div><div class="line">        newLists[newCount++] = oldLists[i];</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>这里我们需要注意，category并没有完全的替换掉原有类的同名方法，category的方法被放置在新方法列表的前面，而原来类的方法被放到后面，在runtime中，遍历方法列表查找时，找到了category的方法后，就会停止遍历，这就是我们平时所说的“覆盖”方法。</p>
<h3 id="获取主类方法"><a href="#获取主类方法" class="headerlink" title="获取主类方法"></a>获取主类方法</h3><p>找到源方法很简单，只需要遍历方法列表，找到最后的一个对应名字方法即可，(摘自：美团技术博客)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">Class currentClass = [MyClass class];</div><div class="line">MyClass *my = [[MyClass alloc] init];</div><div class="line"></div><div class="line">if (currentClass) &#123;</div><div class="line">    unsigned int methodCount;</div><div class="line">    Method *methodList = class_copyMethodList(currentClass, &amp;methodCount);</div><div class="line">    IMP lastImp = NULL;</div><div class="line">    SEL lastSel = NULL;</div><div class="line">    for (NSInteger i = 0; i &lt; methodCount; i++) &#123;</div><div class="line">        Method method = methodList[i];</div><div class="line">        NSString *methodName = [NSString stringWithCString:sel_getName(method_getName(method)) </div><div class="line">                                        encoding:NSUTF8StringEncoding];</div><div class="line">        if ([@&quot;printName&quot; isEqualToString:methodName]) &#123;</div><div class="line">            lastImp = method_getImplementation(method);</div><div class="line">            lastSel = method_getName(method);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    typedef void (*fn)(id,SEL);</div><div class="line"></div><div class="line">    if (lastImp != NULL) &#123;</div><div class="line">        fn f = (fn)lastImp;</div><div class="line">        f(my,lastSel);</div><div class="line">    &#125;</div><div class="line">    free(methodList);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="category对象关联"><a href="#category对象关联" class="headerlink" title="category对象关联"></a>category对象关联</h3><p>那么当在 category 中使用对象关联，那么相应的存储位置，生命周期是怎么样的？<br>去探索一下源码，在objc-references.mm文件中<strong>void _object_set_associative_reference</strong>方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line">void _object_set_associative_reference(id object, void *key, id value, uintptr_t policy) &#123;</div><div class="line">    // retain the new value (if any) outside the lock.</div><div class="line">    ObjcAssociation old_association(0, nil);</div><div class="line">    id new_value = value ? acquireValue(value, policy) : nil;</div><div class="line">    &#123;</div><div class="line">        AssociationsManager manager;</div><div class="line">        AssociationsHashMap &amp;associations(manager.associations());</div><div class="line">        disguised_ptr_t disguised_object = DISGUISE(object);</div><div class="line">        if (new_value) &#123;</div><div class="line">            // break any existing association.</div><div class="line">            AssociationsHashMap::iterator i = associations.find(disguised_object);</div><div class="line">            if (i != associations.end()) &#123;</div><div class="line">                // secondary table exists</div><div class="line">                ObjectAssociationMap *refs = i-&gt;second;</div><div class="line">                ObjectAssociationMap::iterator j = refs-&gt;find(key);</div><div class="line">                if (j != refs-&gt;end()) &#123;</div><div class="line">                    old_association = j-&gt;second;</div><div class="line">                    j-&gt;second = ObjcAssociation(policy, new_value);</div><div class="line">                &#125; else &#123;</div><div class="line">                    (*refs)[key] = ObjcAssociation(policy, new_value);</div><div class="line">                &#125;</div><div class="line">            &#125; else &#123;</div><div class="line">                // create the new association (first time).</div><div class="line">                ObjectAssociationMap *refs = new ObjectAssociationMap;</div><div class="line">                associations[disguised_object] = refs;</div><div class="line">                (*refs)[key] = ObjcAssociation(policy, new_value);</div><div class="line">                object-&gt;setHasAssociatedObjects();</div><div class="line">            &#125;</div><div class="line">        &#125; else &#123;</div><div class="line">            // setting the association to nil breaks the association.</div><div class="line">            AssociationsHashMap::iterator i = associations.find(disguised_object);</div><div class="line">            if (i !=  associations.end()) &#123;</div><div class="line">                ObjectAssociationMap *refs = i-&gt;second;</div><div class="line">                ObjectAssociationMap::iterator j = refs-&gt;find(key);</div><div class="line">                if (j != refs-&gt;end()) &#123;</div><div class="line">                    old_association = j-&gt;second;</div><div class="line">                    refs-&gt;erase(j);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    // release the old value (outside of the lock).</div><div class="line">    if (old_association.hasValue()) ReleaseValue()(old_association);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们可以看出，关联对象是由AssociationsManager管理，那么它是什么呢？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">/ class AssociationsManager manages a lock / hash table singleton pair.</div><div class="line">// Allocating an instance acquires the lock, and calling its assocations()</div><div class="line">// method lazily allocates the hash table.</div><div class="line"></div><div class="line">spinlock_t AssociationsManagerLock;</div><div class="line"></div><div class="line">class AssociationsManager &#123;</div><div class="line">    // associative references: object pointer -&gt; PtrPtrHashMap.</div><div class="line">    static AssociationsHashMap *_map;</div><div class="line">public:</div><div class="line">    AssociationsManager()   &#123; AssociationsManagerLock.lock(); &#125;</div><div class="line">    ~AssociationsManager()  &#123; AssociationsManagerLock.unlock(); &#125;</div><div class="line">    </div><div class="line">    AssociationsHashMap &amp;associations() &#123;</div><div class="line">        if (_map == NULL)</div><div class="line">            _map = new AssociationsHashMap();</div><div class="line">        return *_map;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">AssociationsHashMap *AssociationsManager::_map = NULL;</div></pre></td></tr></table></figure></p>
<p>AssociationsManager 是一个静态的全局 AssociationsHashMap，用来存储所有的关联对象，key是对象的内存地址，value则是另一个 AssociationsHashMap，其中存储了关联对象的kv，对象销毁的工作则交给 <strong>objc_destructInstance</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">void *objc_destructInstance(id obj) </div><div class="line">&#123;</div><div class="line">    if (obj) &#123;</div><div class="line">        Class isa_gen = _object_getClass(obj);</div><div class="line">        class_t *isa = newcls(isa_gen);</div><div class="line"></div><div class="line">        // Read all of the flags at once for performance.</div><div class="line">        bool cxx = hasCxxStructors(isa);</div><div class="line">        bool assoc = !UseGC &amp;&amp; _class_instancesHaveAssociatedObjects(isa_gen);</div><div class="line"></div><div class="line">        // This order is important.</div><div class="line">        if (cxx) object_cxxDestruct(obj);</div><div class="line">        if (assoc) _object_remove_assocations(obj);</div><div class="line"></div><div class="line">        if (!UseGC) objc_clear_deallocating(obj);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    return obj;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>如有错误请指正~</p>
<p>参考链接：<br><a href="https://tech.meituan.com/DiveIntoCategory.html" target="_blank" rel="external">https://tech.meituan.com/DiveIntoCategory.html</a><br><a href="http://blog.leichunfeng.com/blog/2015/05/18/objective-c-category-implementation-principle/" target="_blank" rel="external">http://blog.leichunfeng.com/blog/2015/05/18/objective-c-category-implementation-principle/</a><br><a href="https://developer.apple.com/library/ios/documentation/General/Conceptual/DevPedia-CocoaCore/Category.html#//apple_ref/doc/uid/TP40008195-CH5-SW1" target="_blank" rel="external">https://developer.apple.com/library/ios/documentation/General/Conceptual/DevPedia-CocoaCore/Category.html#//apple_ref/doc/uid/TP40008195-CH5-SW1</a> <a href="http://stackoverflow.com/questions/5272451/overriding-methods-using-categories-in-objective-c" target="_blank" rel="external">http://stackoverflow.com/questions/5272451/overriding-methods-using-categories-in-objective-c</a></p>
<p><a href="https://opensource.apple.com/tarballs/objc4/" target="_blank" rel="external">这里可以看到源码</a></p>
</div><script type="text/javascript" src="/js/share.js?v=0.0.0" async></script><a data-url="http://asution.github.io/2017/08/25/iOS中的Category详解/" data-id="cj75v2wvo000c084u39z8s4qv" class="article-share-link">分享</a><div class="tags"><a href="/tags/iOS/">iOS</a></div><div class="post-nav"><a href="/2017/08/25/iOS中的-load与-initialize/" class="next">iOS中的+load与+initialize</a></div><div id="cloud-tie-wrapper" class="cloud-tie-wrapper"></div><script>var cloudTieConfig = {
  url: document.location.href,
  sourceId: "",
  productKey: "true",
  target: "cloud-tie-wrapper"
};</script><script src="https://img1.cache.netease.com/f2e/tie/yun/sdk/loader.js"></script></div></div></div><div class="pure-u-1 pure-u-md-1-4"><div id="sidebar"><div class="widget"><form action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank" class="search-form"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="http://asution.github.io"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/网络相关/" style="font-size: 15px;">网络相关</a> <a href="/tags/block/" style="font-size: 15px;">block</a> <a href="/tags/iOS/" style="font-size: 15px;">iOS</a> <a href="/tags/React-native/" style="font-size: 15px;">React-native</a> <a href="/tags/基础/" style="font-size: 15px;">基础</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2017/08/25/iOS中的Category详解/">iOS中的Category详解</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/08/25/iOS中的-load与-initialize/">iOS中的+load与+initialize</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/06/14/ConnectionInterent/">网络是怎样连接的:Web浏览器/应用程序</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/06/07/WWDC2017/">iOS开发者应该知道的</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/05/31/system/">计算机中的进制</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/05/12/iOS-NSURLSession/">IOS网络请求之-NSURLSession</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/05/11/iOS-Block/">OC的block详细解析</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/05/10/react-native-04-01Flexbox布局/">react-native从入门到放弃（4.1）Flexbox布局</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/05/10/react-native-04/">react-native从入门到放弃（4）样式与布局</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/05/10/react-native-03-01/">react-native从入门到放弃（3.1）RN组件生命周期</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2017 <a href="/." rel="nofollow">崔浩楠 Blog.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a id="rocket" href="#top" class="show"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.0.47/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.0.47/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>